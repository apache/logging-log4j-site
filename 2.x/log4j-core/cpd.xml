<?xml version="1.0" encoding="UTF-8"?>
<pmd-cpd>
<duplication lines="24" tokens="211">
<file line="83" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/config/JSONConfiguration.java"/>
<file line="103" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/config/XMLConfiguration.java"/>
<codefragment>
<![CDATA[
            for (final Map.Entry<String, String> entry : rootNode.getAttributes().entrySet()) {
                if ("status".equalsIgnoreCase(entry.getKey())) {
                    status = Level.toLevel(getSubst().replace(entry.getValue()), null);
                    if (status == null) {
                        status = Level.ERROR;
                        messages.add("Invalid status specified: " + entry.getValue() + ". Defaulting to ERROR");
                    }
                } else if ("dest".equalsIgnoreCase(entry.getKey())) {
                    final String dest = entry.getValue();
                    if (dest != null) {
                        if (dest.equalsIgnoreCase("err")) {
                            stream = System.err;
                        } else {
                            try {
                                final File destFile = FileUtils.fileFromURI(new URI(dest));
                                stream = new PrintStream(new FileOutputStream(destFile));
                            } catch (final URISyntaxException use) {
                                System.err.println("Unable to write to " + dest + ". Writing to stdout");
                            }
                        }
                    }
                } else if ("verbose".equalsIgnoreCase(entry.getKey())) {
                    verbose = Boolean.parseBoolean(getSubst().replace(entry.getValue()));
                } else if ("packages".equalsIgnoreCase(entry.getKey())) {
]]>
</codefragment>
</duplication>
<duplication lines="26" tokens="165">
<file line="124" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/filter/MapFilter.java"/>
<file line="109" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/filter/StructuredDataFilter.java"/>
<file line="119" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/filter/ThreadContextMapFilter.java"/>
<codefragment>
<![CDATA[
            LOGGER.error("keys and values must be specified for the MapFilter");
            return null;
        }
        final Map<String, List<String>> map = new HashMap<String, List<String>>();
        for (final KeyValuePair pair : pairs) {
            final String key = pair.getKey();
            if (key == null) {
                LOGGER.error("A null key is not valid in MapFilter");
                continue;
            }
            final String value = pair.getValue();
            if (value == null) {
                LOGGER.error("A null value for key " + key + " is not allowed in MapFilter");
                continue;
            }
            List<String> list = map.get(pair.getKey());
            if (list != null) {
                list.add(value);
            } else {
                list = new ArrayList<String>();
                list.add(value);
                map.put(pair.getKey(), list);
            }
        }
        if (map.size() == 0) {
            LOGGER.error("MapFilter is not configured with any valid key value pairs");
]]>
</codefragment>
</duplication>
<duplication lines="43" tokens="157">
<file line="108" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/net/JMSQueueManager.java"/>
<file line="109" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/net/JMSTopicManager.java"/>
<codefragment>
<![CDATA[
            super.send(object, info.session, info.sender);
        } catch (final Exception ex) {
            cleanup(true);
            throw ex;
        }
    }

    @Override
    public void releaseSub() {
        if (info != null) {
            cleanup(false);
        }
    }

    private void cleanup(final boolean quiet) {
        try {
            info.session.close();
        } catch (final Exception e) {
            if (!quiet) {
                LOGGER.error("Error closing session for " + getName(), e);
            }
        }
        try {
            info.conn.close();
        } catch (final Exception e) {
            if (!quiet) {
                LOGGER.error("Error closing connection for " + getName(), e);
            }
        }
        info = null;
    }

    /**
     * Data for the factory.
     */
    private static class FactoryData {
        private final String factoryName;
        private final String providerURL;
        private final String urlPkgPrefixes;
        private final String securityPrincipalName;
        private final String securityCredentials;
        private final String factoryBindingName;
        private final String queueBindingName;
]]>
</codefragment>
</duplication>
<duplication lines="18" tokens="147">
<file line="73" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/pattern/ExtendedThrowablePatternConverter.java"/>
<file line="74" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/pattern/RootThrowablePatternConverter.java"/>
<codefragment>
<![CDATA[
    public static ExtendedThrowablePatternConverter newInstance(final String[] options) {
        String type = null;
        String[] array = options;
        if (options != null && options.length == 1 && options[0].length() > 0) {
            final String[] opts = options[0].split(",", 2);
            final String first = opts[0].trim();
            String filter;
            final Scanner scanner = new Scanner(first);
            if (first.equalsIgnoreCase(FULL) || first.equalsIgnoreCase(SHORT) || scanner.hasNextInt()) {
                type = first;
                filter = opts[1].trim();
            } else {
                filter = options[0].trim();
            }
            array = new String[] {type, filter};
        }

        return new ExtendedThrowablePatternConverter(array);
]]>
</codefragment>
</duplication>
<duplication lines="23" tokens="139">
<file line="201" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/layout/HTMLLayout.java"/>
<file line="227" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java"/>
<codefragment>
<![CDATA[
    private void appendThrowableAsHTML(final Throwable throwable, final StringBuilder sbuf) {
        final StringWriter sw = new StringWriter();
        final PrintWriter pw = new PrintWriter(sw);
        try {
            throwable.printStackTrace(pw);
        } catch (final RuntimeException ex) {
            // Ignore the exception.
        }
        pw.flush();
        final LineNumberReader reader = new LineNumberReader(new StringReader(sw.toString()));
        final ArrayList<String> lines = new ArrayList<String>();
        try {
          String line = reader.readLine();
          while (line != null) {
            lines.add(line);
            line = reader.readLine();
          }
        } catch (final IOException ex) {
            if (ex instanceof InterruptedIOException) {
                Thread.currentThread().interrupt();
            }
            lines.add(ex.toString());
        }
]]>
</codefragment>
</duplication>
<duplication lines="25" tokens="138">
<file line="49" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/pattern/ExtendedThrowablePatternConverter.java"/>
<file line="50" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/pattern/RootThrowablePatternConverter.java"/>
<codefragment>
<![CDATA[
        super("ExtendedThrowable", "throwable", options);
        List<String> tempPackages = null;
        if (options != null && options.length > 1) {
            if (options[1].startsWith(FILTERS) && options[1].endsWith(")")) {
                final String filterStr = options[1].substring(FILTERS.length(), options[1].length() - 1);
                final String[] array = filterStr.split(",");
                if (array.length > 0) {
                    tempPackages = new ArrayList<String>(array.length);
                    for (final String token : array) {
                        tempPackages.add(token.trim());
                    }
                }
            }
        }
        packages = tempPackages;
    }

    /**
     * Gets an instance of the class.
     *
     * @param options pattern options, may be null.  If first element is "short",
     *                only the first line of the throwable will be formatted.
     * @return instance of class.
     */
    public static ExtendedThrowablePatternConverter newInstance(final String[] options) {
]]>
</codefragment>
</duplication>
<duplication lines="20" tokens="136">
<file line="105" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/pattern/ExtendedThrowablePatternConverter.java"/>
<file line="106" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/pattern/RootThrowablePatternConverter.java"/>
<codefragment>
<![CDATA[
            final String trace = t.getExtendedStackTrace(packages);
            final int len = toAppendTo.length();
            if (len > 0 && !Character.isWhitespace(toAppendTo.charAt(len - 1))) {
                toAppendTo.append(" ");
            }
            if (lines != Integer.MAX_VALUE) {
                final StringBuilder sb = new StringBuilder();
                final String[] array = trace.split("\n");
                final int limit = lines > array.length ? array.length : lines;
                for (int i = 0; i < limit; ++i) {
                    sb.append(array[i]).append("\n");
                }
                toAppendTo.append(sb.toString());

            } else {
                toAppendTo.append(trace);
            }
        }
    }
}
]]>
</codefragment>
</duplication>
<duplication lines="33" tokens="131">
<file line="88" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/filter/BurstFilter.java"/>
<file line="56" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/filter/DynamicThresholdFilter.java"/>
<file line="44" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/filter/ThresholdFilter.java"/>
<codefragment>
<![CDATA[
    }

    @Override
    public Result filter(final Logger logger, final Level level, final Marker marker, final String msg,
                         final Object... params) {
        return filter(level);
    }

    @Override
    public Result filter(final Logger logger, final Level level, final Marker marker, final Object msg,
                         final Throwable t) {
        return filter(level);
    }

    @Override
    public Result filter(final Logger logger, final Level level, final Marker marker, final Message msg,
                         final Throwable t) {
        return filter(level);
    }

    @Override
    public Result filter(final LogEvent event) {
        return filter(event.getLevel());
    }

    /**
     * Decide if we're going to log <code>event</code> based on whether the
     * maximum burst of log statements has been exceeded.
     *
     * @param level The log level.
     * @return The onMatch value if the filter passes, onMismatch otherwise.
     */
    private Result filter(final Level level) {
]]>
</codefragment>
</duplication>
<duplication lines="41" tokens="126">
<file line="57" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/appender/rolling/helper/GZCompressAction.java"/>
<file line="58" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/appender/rolling/helper/ZipCompressAction.java"/>
<codefragment>
<![CDATA[
    public GZCompressAction(final File source, final File destination, final boolean deleteSource) {
        if (source == null) {
            throw new NullPointerException("source");
        }

        if (destination == null) {
            throw new NullPointerException("destination");
        }

        this.source = source;
        this.destination = destination;
        this.deleteSource = deleteSource;
    }

    /**
     * Compress.
     *
     * @return true if successfully compressed.
     * @throws IOException on IO exception.
     */
    @Override
    public boolean execute() throws IOException {
        return execute(source, destination, deleteSource);
    }

    /**
     * Compress a file.
     *
     * @param source       file to compress, may not be null.
     * @param destination  compressed file, may not be null.
     * @param deleteSource if true, attempt to delete file on completion.  Failure to delete
     *                     does not cause an exception to be thrown or affect return value.
     * @return true if source file compressed.
     * @throws IOException on IO exception.
     */
    public static boolean execute(final File source, final File destination, final boolean deleteSource)
        throws IOException {
        if (source.exists()) {
            final FileInputStream fis = new FileInputStream(source);
            final FileOutputStream fos = new FileOutputStream(destination);
            final GZIPOutputStream gzos = new GZIPOutputStream(fos);
]]>
</codefragment>
</duplication>
<duplication lines="19" tokens="109">
<file line="124" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/config/JSONConfiguration.java"/>
<file line="147" path="/Users/rgoers/projects/apache/logging/log4j/log4j2/log4j-2.0-beta4/core/src/main/java/org/apache/logging/log4j/core/config/XMLConfiguration.java"/>
<codefragment>
<![CDATA[
                final StatusListener listener = statusIter.next();
                if (listener instanceof StatusConsoleListener) {
                    found = true;
                    ((StatusConsoleListener) listener).setLevel(status);
                    if (!verbose) {
                        ((StatusConsoleListener) listener).setFilters(VERBOSE_CLASSES);
                    }
                }
            }
            if (!found && status != Level.OFF) {
                final StatusConsoleListener listener = new StatusConsoleListener(status, stream);
                if (!verbose) {
                    listener.setFilters(VERBOSE_CLASSES);
                }
                ((StatusLogger) LOGGER).registerListener(listener);
                for (final String msg : messages) {
                    LOGGER.error(msg);
                }
            }
]]>
</codefragment>
</duplication>
</pmd-cpd>