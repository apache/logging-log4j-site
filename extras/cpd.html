<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

-->
<!-- Generated by Apache Maven Doxia at Oct 14, 2013 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>CPD Results</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta name="Date-Revision-yyyymmdd" content="20131014" />
    <meta http-equiv="Content-Language" content="en" />
      </head>
  <body class="composite">
    <div id="banner">
                  <a href="../../" id="bannerLeft">
                                                <img src="images/ls-logo.jpg" alt="Apache Logging Services" />
                </a>
                        <a href=".." id="bannerRight">
                                                <img src="images/logo.jpg" alt="Apache log4j" />
                </a>
            <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
        
                <div class="xleft">
        <span id="publishDate">Last Published: 2013-10-14</span>
                  &nbsp;| <span id="projectVersion">Version: 1.2.17</span>
                          |                           <a href="http://www.apache.org/" class="externalLink" title="Apache">Apache</a>
                &gt;
                              <a href="../../" title="Logging Services">Logging Services</a>
                &gt;
                              <a href="../" title="log4j">log4j</a>
                &gt;
                              <a href="./" title="Extras">Extras</a>
                          </div>
            <div class="xright">        
        
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
        
                                <h5>Get it</h5>
                  <ul>
                  <li class="none">
                          <a href="download.html" title="Download">Download</a>
            </li>
                  <li class="none">
                          <a href="changes-report.html" title="Changes">Changes</a>
            </li>
                  <li class="none">
                          <a href="http://www.apache.org/licenses/" class="externalLink" title="License">License</a>
            </li>
          </ul>
                       <h5>About</h5>
                  <ul>
                  <li class="none">
                          <a href="index.html" title="What is it?">What is it?</a>
            </li>
                  <li class="none">
                          <a href="roadmap.html" title="Roadmap">Roadmap</a>
            </li>
                  <li class="none">
                          <a href="apidocs/index.html" title="JavaDoc">JavaDoc</a>
            </li>
          </ul>
                       <h5>More</h5>
                  <ul>
                  <li class="none">
                          <a href="../1.2/" title="Apache log4j 1.x">Apache log4j 1.x</a>
            </li>
                  <li class="none">
                          <a href="../2.x/" title="Apache log4j 2.x">Apache log4j 2.x</a>
            </li>
          </ul>
                       <h5>Community</h5>
                  <ul>
                  <li class="none">
                          <a href="mail-lists.html" title="Mailing Lists">Mailing Lists</a>
            </li>
                  <li class="none">
                          <a href="issue-tracking.html" title="Issue Tracking">Issue Tracking</a>
            </li>
          </ul>
                       <h5>Project Documentation</h5>
                  <ul>
                                                                                                                                            <li class="collapsed">
                          <a href="project-info.html" title="Project Information">Project Information</a>
                  </li>
                                                                                                                                                                        <li class="expanded">
                          <a href="project-reports.html" title="Project Reports">Project Reports</a>
                    <ul>
                      <li class="none">
                          <a href="changes-report.html" title="Changes Report">Changes Report</a>
            </li>
                      <li class="none">
                          <a href="pmd.html" title="PMD Report">PMD Report</a>
            </li>
                      <li class="none">
            <strong>CPD Report</strong>
          </li>
                      <li class="none">
                          <a href="apidocs/index.html" title="JavaDocs">JavaDocs</a>
            </li>
                      <li class="none">
                          <a href="testapidocs/index.html" title="Test JavaDocs">Test JavaDocs</a>
            </li>
                      <li class="none">
                          <a href="rat-report.html" title="RAT Report">RAT Report</a>
            </li>
              </ul>
        </li>
          </ul>
                       <h5>Development</h5>
                  <ul>
                  <li class="none">
                          <a href="source-repository.html" title="Repository">Repository</a>
            </li>
                  <li class="none">
                          <a href="dependencies.html" title="Dependencies">Dependencies</a>
            </li>
                  <li class="none">
                          <a href="integration.html" title="Continuous Integration">Continuous Integration</a>
            </li>
          </ul>
                       <h5>Apache</h5>
                  <ul>
                  <li class="none">
                          <a href="http://www.apache.org" class="externalLink" title="Home">Home</a>
            </li>
                  <li class="none">
                          <a href="http://www.apache.org/foundation/sponsorship.html" class="externalLink" title="Sponsorship">Sponsorship</a>
            </li>
                  <li class="none">
                          <a href="http://www.apache.org/foundation/thanks.html" class="externalLink" title="Thanks">Thanks</a>
            </li>
                  <li class="none">
                          <a href="http://www.apache.org/security/" class="externalLink" title="Security">Security</a>
            </li>
                  <li class="none">
                          <a href="http://www.apachecon.com" class="externalLink" title="Conferences">Conferences</a>
            </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                   
        
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section"><h2>CPD Results<a name="CPD_Results"></a></h2><p>The following document contains the results of PMD's  <a class="externalLink" href="http://pmd.sourceforge.net/cpd.html">CPD</a> 4.3.</p></div><div class="section"><h2>Duplications<a name="Duplications"></a></h2><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/apache/log4j/extras/XSLTLayout.java</td><td>100</td></tr><tr class="a"><td>org/apache/log4j/xml/XSLTLayout.java</td><td>96</td></tr><tr class="b"><td colspan='2'><div><pre>        implements org.apache.log4j.xml.UnrecognizedElementHandler {
    /**
     * Namespace for XSLT.
     */
    private static final String XSLT_NS = &quot;http://www.w3.org/1999/XSL/Transform&quot;;
    /**
     * Namespace for log4j events.
     */
    private static final String LOG4J_NS = &quot;http://jakarta.apache.org/log4j/&quot;;
    /**
     * Whether location information should be written.
     */
    private boolean locationInfo = false;
    /**
     * media-type (mime type) extracted from XSLT transform.
     */
    private String mediaType = &quot;text/plain&quot;;
    /**
     * Encoding extracted from XSLT transform.
     */
    private Charset encoding;
    /**
     * Transformer factory.
     */
    private SAXTransformerFactory transformerFactory;
    /**
     * XSLT templates.
     */
    private Templates templates;
    /**
     * Output stream.
     */
    private final ByteArrayOutputStream outputStream;
    /**
     * Whether throwable information should be ignored.
     */
    private boolean ignoresThrowable = false;
    /**
     * Whether properties should be extracted.
     */
    private boolean properties = true;
    /**
     * Whether activateOptions has been called.
     */
    private boolean activated = false;

    /**
     * DateFormat for UTC time.
     */
    private final CachedDateFormat utcDateFormat;

    /**
     * Default constructor.
     *
     */
    public XSLTLayout() {
        outputStream = new ByteArrayOutputStream();
        transformerFactory = (SAXTransformerFactory)
                TransformerFactory.newInstance();

        SimpleDateFormat zdf = new SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss.SSS'Z'&quot;);
        zdf.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));
        utcDateFormat = new CachedDateFormat(zdf, 1000);
    }

    /**
     * {@inheritDoc}
     */
    public synchronized String getContentType() {
        return mediaType;
    }

    /**
     * The &lt;b&gt;LocationInfo &lt;/b&gt; option takes a boolean value. By default, it is
     * set to false which means there will be no location information output by
     * this layout. If the the option is set to true, then the file name and line
     * number of the statement at the origin of the log statement will be output.
     *
     * &lt;p&gt;
     * If you are embedding this layout within an {@link
     * org.apache.log4j.net.SMTPAppender} then make sure to set the
     * &lt;b&gt;LocationInfo &lt;/b&gt; option of that appender as well.
     *
     * @param flag new value.
     */
    public synchronized void setLocationInfo(final boolean flag) {
      locationInfo = flag;
    }

    /**
     * Gets whether location info should be output.
     * @return if location is output.
     */
    public synchronized boolean getLocationInfo() {
      return locationInfo;
    }

    /**
     * Sets whether MDC key-value pairs should be output, default false.
     * @param flag new value.
     */
    public synchronized void setProperties(final boolean flag) {
      properties = flag;
    }

    /**
     * Gets whether MDC key-value pairs should be output.
     * @return true if MDC key-value pairs are output.
     */
    public synchronized boolean getProperties() {
      return properties;
    }


    /** {@inheritDoc} */
    public synchronized void activateOptions() {
        if (templates == null) {
            try {
                InputStream is = XSLTLayout.class.getResourceAsStream(&quot;default.xslt&quot;);
                StreamSource ss = new StreamSource(is);
                templates = transformerFactory.newTemplates(ss);
                encoding = Charset.forName(&quot;US-ASCII&quot;);
                mediaType = &quot;text/plain&quot;;
            } catch (Exception ex) {
                LogLog.error(&quot;Error loading default.xslt&quot;, ex);
            }
        }
        activated = true;
    }

    /**
     * Gets whether throwables should not be output.
     * @return true if throwables should not be output.
     */
    public synchronized boolean ignoresThrowable() {
        return ignoresThrowable;
    }

    /**
     * Sets whether throwables should not be output.
     * @param ignoresThrowable if true, throwables should not be output.
    */
    public synchronized void setIgnoresThrowable(boolean ignoresThrowable) {
      this.ignoresThrowable = ignoresThrowable;
    }



    /**
     * {@inheritDoc}
     */
    public synchronized String format(final LoggingEvent event) {
      if (!activated) {
          activateOptions();
      }
      if (templates != null &amp;&amp; encoding != null) {
          outputStream.reset();

          try {
            TransformerHandler transformer =
                      transformerFactory.newTransformerHandler(templates);

            transformer.setResult(new StreamResult(outputStream));
            transformer.startDocument();

            //
            //   event element
            //
            AttributesImpl attrs = new AttributesImpl();
            attrs.addAttribute(null, &quot;logger&quot;, &quot;logger&quot;,
                    &quot;CDATA&quot;, event.getLoggerName());
            attrs.addAttribute(null, &quot;timestamp&quot;, &quot;timestamp&quot;,
                    &quot;CDATA&quot;, Long.toString(event.timeStamp));
            attrs.addAttribute(null, &quot;level&quot;, &quot;level&quot;,
                    &quot;CDATA&quot;, event.getLevel().toString());
            attrs.addAttribute(null, &quot;thread&quot;, &quot;thread&quot;,
                    &quot;CDATA&quot;, event.getThreadName());
            StringBuffer buf = new StringBuffer();
            utcDateFormat.format(event.timeStamp, buf);
            attrs.addAttribute(null, &quot;time&quot;, &quot;time&quot;, &quot;CDATA&quot;, buf.toString());


            transformer.startElement(LOG4J_NS, &quot;event&quot;, &quot;event&quot;, attrs);
            attrs.clear();

            //
            //   message element
            //
            transformer.startElement(LOG4J_NS, &quot;message&quot;, &quot;message&quot;, attrs);
            String msg = event.getRenderedMessage();
            if (msg != null &amp;&amp; msg.length() &gt; 0) {
                transformer.characters(msg.toCharArray(), 0, msg.length());
            }
            transformer.endElement(LOG4J_NS, &quot;message&quot;, &quot;message&quot;);

            //
            //    NDC element
            //
            String ndc = event.getNDC();
            if (ndc != null) {
                transformer.startElement(LOG4J_NS, &quot;NDC&quot;, &quot;NDC&quot;, attrs);
                char[] ndcChars = ndc.toCharArray();
                transformer.characters(ndcChars, 0, ndcChars.length);
                transformer.endElement(LOG4J_NS, &quot;NDC&quot;, &quot;NDC&quot;);
            }

            //
            //    throwable element unless suppressed
            //
              if (!ignoresThrowable) {
                String[] s = event.getThrowableStrRep();
                if (s != null) {
                    transformer.startElement(LOG4J_NS, &quot;throwable&quot;,
                            &quot;throwable&quot;, attrs);
                    char[] nl = new char[] { '\n' };
                    for (int i = 0; i &lt; s.length; i++) {
                        char[] line = s[i].toCharArray();
                        transformer.characters(line, 0, line.length);
                        transformer.characters(nl, 0, nl.length);
                    }
                    transformer.endElement(LOG4J_NS, &quot;throwable&quot;, &quot;throwable&quot;);
                }
              }

              //
              //     location info unless suppressed
              //
              //
              if (locationInfo) {
                LocationInfo locationInfo = event.getLocationInformation();
                attrs.addAttribute(null, &quot;class&quot;, &quot;class&quot;, &quot;CDATA&quot;,
                        locationInfo.getClassName());
                attrs.addAttribute(null, &quot;method&quot;, &quot;method&quot;, &quot;CDATA&quot;,
                          locationInfo.getMethodName());
                attrs.addAttribute(null, &quot;file&quot;, &quot;file&quot;, &quot;CDATA&quot;,
                            locationInfo.getFileName());
                attrs.addAttribute(null, &quot;line&quot;, &quot;line&quot;, &quot;CDATA&quot;,
                            locationInfo.getLineNumber());
                transformer.startElement(LOG4J_NS, &quot;locationInfo&quot;,
                        &quot;locationInfo&quot;, attrs);
                transformer.endElement(LOG4J_NS, &quot;locationInfo&quot;,
                        &quot;locationInfo&quot;);
              }

              if (properties) {
                //
                //    write MDC contents out as properties element
                //
                Set mdcKeySet = MDCKeySetExtractor.INSTANCE.getPropertyKeySet(event);

                if ((mdcKeySet != null) &amp;&amp; (mdcKeySet.size() &gt; 0)) {
                    attrs.clear();
                    transformer.startElement(LOG4J_NS,
                            &quot;properties&quot;, &quot;properties&quot;, attrs);
                    Object[] keys = mdcKeySet.toArray();
                    Arrays.sort(keys);
                    for (int i = 0; i &lt; keys.length; i++) {
                        String key = keys[i].toString();
                        Object val = event.getMDC(key);
                        attrs.clear();
                        attrs.addAttribute(null, &quot;name&quot;, &quot;name&quot;, &quot;CDATA&quot;, key);
                        attrs.addAttribute(null, &quot;value&quot;, &quot;value&quot;,
                                &quot;CDATA&quot;, val.toString());
                        transformer.startElement(LOG4J_NS,
                                &quot;data&quot;, &quot;data&quot;, attrs);
                        transformer.endElement(LOG4J_NS, &quot;data&quot;, &quot;data&quot;);
                    }
                }
              }


            transformer.endElement(LOG4J_NS, &quot;event&quot;, &quot;event&quot;);
            transformer.endDocument();

            String body = encoding.decode(
                    ByteBuffer.wrap(outputStream.toByteArray())).toString();
            outputStream.reset();
            //
            //   must remove XML declaration since it may
            //      result in erroneous encoding info
            //      if written by FileAppender in a different encoding
            if (body.startsWith(&quot;&lt;?xml &quot;)) {
                int endDecl = body.indexOf(&quot;?&gt;&quot;);
                if (endDecl != -1) {
                    for(endDecl += 2; 
					     endDecl &lt; body.length() &amp;&amp;
						 (body.charAt(endDecl) == '\n' || body.charAt(endDecl) == '\r'); 
						 endDecl++);
                    return body.substring(endDecl);
                }
            }
            return body;
          } catch (Exception ex) {
              LogLog.error(&quot;Error during transformation&quot;, ex);
              return ex.toString();
          }
      }
      return &quot;No valid transform or encoding specified.&quot;;
    }

    /**
     * Sets XSLT transform.
     * @param xsltdoc DOM document containing XSLT transform source,
     * may be modified.
     * @throws TransformerConfigurationException if transformer can not be
     * created.
     */
    public void setTransform(final Document xsltdoc)
            throws TransformerConfigurationException {
        //
        //  scan transform source for xsl:output elements
        //    and extract encoding, media (mime) type and output method
        //
        String encodingName = null;
        mediaType = null;
        String method = null;
        NodeList nodes = xsltdoc.getElementsByTagNameNS(
                XSLT_NS,
                &quot;output&quot;);
        for(int i = 0; i &lt; nodes.getLength(); i++) {
            Element outputElement = (Element) nodes.item(i);
            if (method == null || method.length() == 0) {
                method = outputElement.getAttributeNS(null, &quot;method&quot;);
            }
            if (encodingName == null || encodingName.length() == 0) {
                encodingName = outputElement.getAttributeNS(null, &quot;encoding&quot;);
            }
            if (mediaType == null || mediaType.length() == 0) {
                mediaType = outputElement.getAttributeNS(null, &quot;media-type&quot;);
            }
        }

        if (mediaType == null || mediaType.length() == 0) {
            if (&quot;html&quot;.equals(method)) {
                mediaType = &quot;text/html&quot;;
            } else if (&quot;xml&quot;.equals(method)) {
                mediaType = &quot;text/xml&quot;;
            } else {
                mediaType = &quot;text/plain&quot;;
            }
        }

        //
        //  if encoding was not specified,
        //     add xsl:output encoding=US-ASCII to XSLT source
        //
        if (encodingName == null || encodingName.length() == 0) {
            Element transformElement = xsltdoc.getDocumentElement();
            Element outputElement = xsltdoc.
                    createElementNS(XSLT_NS, &quot;output&quot;);
            outputElement.setAttributeNS(null, &quot;encoding&quot;, &quot;US-ASCII&quot;);
            transformElement.insertBefore(outputElement, transformElement.getFirstChild());
            encoding = Charset.forName(&quot;US-ASCII&quot;);
        } else {
            encoding = Charset.forName(encodingName);
        }

        DOMSource transformSource = new DOMSource(xsltdoc);
        
        templates = transformerFactory.newTemplates(transformSource);

    }

    /**
     * {@inheritDoc}
     */
    public boolean parseUnrecognizedElement(final Element element,
                                            final Properties props)
            throws Exception {
        if (XSLT_NS.equals(element.getNamespaceURI()) ||
                element.getNodeName().indexOf(&quot;transform&quot;) != -1 ||
                element.getNodeName().indexOf(&quot;stylesheet&quot;) != -1) {
            //
            //   DOMConfigurator typically not namespace aware
            //     serialize tree and reparse.
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            DOMSource source = new DOMSource(element);
            TransformerFactory transformerFactory = TransformerFactory.newInstance();
            Transformer transformer = transformerFactory.newTransformer();
            transformer.transform(source, new StreamResult(os));

            ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
            DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
            domFactory.setNamespaceAware(true);
            Document xsltdoc = domFactory.newDocumentBuilder().parse(is);
            setTransform(xsltdoc);
            return true;
        }
        return false;
    }


}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/apache/log4j/extras/UtilLoggingLevel.java</td><td>57</td></tr><tr class="a"><td>org/apache/log4j/receivers/helpers/UtilLoggingLevel.java</td><td>54</td></tr><tr class="b"><td colspan='2'><div><pre>    public static final int CONFIG_INT = 14000;
    /**
     * Numerical value for FINE.
     */
    public static final int FINE_INT = 13000;
    /**
     * Numerical value for FINER.
     */
    public static final int FINER_INT = 12000;
    /**
     * Numerical value for FINEST.
     */
    public static final int FINEST_INT = 11000;
    /**
     * Numerical value for UNKNOWN.
     */
    public static final int UNKNOWN_INT = 10000;

    /**
     * SEVERE.
     */
    public static final UtilLoggingLevel SEVERE =
            new UtilLoggingLevel(SEVERE_INT, &quot;SEVERE&quot;, 0);
    /**
     * WARNING.
     */
    public static final UtilLoggingLevel WARNING =
            new UtilLoggingLevel(WARNING_INT, &quot;WARNING&quot;, 4);
    /**
     * INFO.
     */
    public static final UtilLoggingLevel INFO =
            new UtilLoggingLevel(INFO_INT, &quot;INFO&quot;, 5);
    /**
     * CONFIG.
     */
    public static final UtilLoggingLevel CONFIG =
            new UtilLoggingLevel(CONFIG_INT, &quot;CONFIG&quot;, 6);
    /**
     * FINE.
     */
    public static final UtilLoggingLevel FINE =
            new UtilLoggingLevel(FINE_INT, &quot;FINE&quot;, 7);
    /**
     * FINER.
     */
    public static final UtilLoggingLevel FINER =
            new UtilLoggingLevel(FINER_INT, &quot;FINER&quot;, 8);
    /**
     * FINEST.
     */
    public static final UtilLoggingLevel FINEST =
            new UtilLoggingLevel(FINEST_INT, &quot;FINEST&quot;, 9);

    /**
     * Create new instance.
     * @param level numeric value for level.
     * @param levelStr symbolic name for level.
     * @param syslogEquivalent Equivalent syslog severity.
     */
    protected UtilLoggingLevel(final int level,
                               final String levelStr,
                               final int syslogEquivalent) {
        super(level, levelStr, syslogEquivalent);
    }

    /**
     * Convert an integer passed as argument to a level. If the
     * conversion fails, then this method returns the specified default.
     * @param val numeric value.
     * @param defaultLevel level to be returned if no level matches
     * numeric value.
     * @return matching level or default level.
     */
    public static UtilLoggingLevel toLevel(final int val,
                               final UtilLoggingLevel defaultLevel) {
        switch (val) {
            case SEVERE_INT:
                return SEVERE;

            case WARNING_INT:
                return WARNING;

            case INFO_INT:
                return INFO;

            case CONFIG_INT:
                return CONFIG;

            case FINE_INT:
                return FINE;

            case FINER_INT:
                return FINER;

            case FINEST_INT:
                return FINEST;

            default:
                return defaultLevel;
        }
    }

    /**
     * Gets level matching numeric value.
     * @param val numeric value.
     * @return  matching level or UtilLoggerLevel.FINEST if no match.
     */
    public static Level toLevel(final int val) {
        return toLevel(val, FINEST);
    }

    /**
     * Gets list of supported levels.
     * @return  list of supported levels.
     */
    public static List getAllPossibleLevels() {
        ArrayList list = new ArrayList();
        list.add(FINE);
        list.add(FINER);
        list.add(FINEST);
        list.add(INFO);
        list.add(CONFIG);
        list.add(WARNING);
        list.add(SEVERE);
        return list;
    }

    /**
     * Get level with specified symbolic name.
     * @param s symbolic name.
     * @return matching level or Level.DEBUG if no match.
     */
    public static Level toLevel(final String s) {
        return toLevel(s, Level.DEBUG);
    }


    /**
     * Get level with specified symbolic name.
     * @param sArg symbolic name.
     * @param defaultLevel level to return if no match.
     * @return matching level or defaultLevel if no match.
     */
    public static Level toLevel(final String sArg,
                                final Level defaultLevel) {
        if (sArg == null) {
            return defaultLevel;
        }

        String s = sArg.toUpperCase();

        if (s.equals(&quot;SEVERE&quot;)) {
            return SEVERE;
        }

        //if(s.equals(&quot;FINE&quot;)) return Level.FINE;
        if (s.equals(&quot;WARNING&quot;)) {
            return WARNING;
        }

        if (s.equals(&quot;INFO&quot;)) {
            return INFO;
        }

        if (s.equals(&quot;CONFI&quot;)) {
            return CONFIG;
        }

        if (s.equals(&quot;FINE&quot;)) {
            return FINE;
        }

        if (s.equals(&quot;FINER&quot;)) {
            return FINER;
        }

        if (s.equals(&quot;FINEST&quot;)) {
            return FINEST;
        }
        return defaultLevel;
    }

}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/apache/log4j/receivers/xml/UtilLoggingXMLDecoder.java</td><td>159</td></tr><tr class="a"><td>org/apache/log4j/receivers/xml/XMLDecoder.java</td><td>164</td></tr><tr class="b"><td colspan='2'><div><pre>      InputSource inputSource =
        new InputSource(new StringReader(buf.toString()));
      document = docBuilder.parse(inputSource);
    } catch (Exception e) {
      e.printStackTrace();
    }

    return document;
  }

  /**
   * Decodes a File into a Vector of LoggingEvents.
   * @param url the url of a file containing events to decode
   * @return Vector of LoggingEvents
   * @throws IOException if IO error during processing.
   */
  public Vector decode(final URL url) throws IOException {
    LineNumberReader reader;
    boolean isZipFile = url.getPath().toLowerCase().endsWith(&quot;.zip&quot;);
    InputStream inputStream;
    if (isZipFile) {
        inputStream = new ZipInputStream(url.openStream());
        //move stream to next entry so we can read it
        ((ZipInputStream)inputStream).getNextEntry();
    } else {
        inputStream = url.openStream();
    }
    if (owner != null) {
        reader = new LineNumberReader(
                new InputStreamReader(
                        new ProgressMonitorInputStream(owner,
                                &quot;Loading &quot; + url , inputStream), ENCODING));
    } else {
        reader = new LineNumberReader(new InputStreamReader(inputStream, ENCODING));
    }
    Vector v = new Vector();

      String line;
      Vector events;
      try {
          while ((line = reader.readLine()) != null) {
              StringBuffer buffer = new StringBuffer(line);
              for (int i = 0; i &lt; 1000; i++) {
                  buffer.append(reader.readLine()).append(&quot;\n&quot;);
              }
              events = decodeEvents(buffer.toString());
              if (events != null) {
                  v.addAll(events);
              }
          }
    } finally {
      partialEvent = null;
      try {
        if (reader != null) {
          reader.close();
        }
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    return v;
  }

  /**
   * Decodes a String representing a number of events into a
   * Vector of LoggingEvents.
   * @param document to decode events from
   * @return Vector of LoggingEvents
   */
  public Vector decodeEvents(final String document) {

      if (document != null) {

          if (document.trim().equals(&quot;&quot;)) {
              return null;
          }

          String newDoc;</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/apache/log4j/receivers/xml/UtilLoggingXMLDecoder.java</td><td>237</td></tr><tr class="a"><td>org/apache/log4j/receivers/xml/XMLDecoder.java</td><td>240</td></tr><tr class="b"><td colspan='2'><div><pre>          String newPartialEvent = null;
          //separate the string into the last portion ending with &lt;/record&gt;
          // (which will be processed) and the partial event which
          // will be combined and processed in the next section

          //if the document does not contain a record end,
          // append it to the partial event string
          if (document.lastIndexOf(RECORD_END) == -1) {
              partialEvent = partialEvent + document;
              return null;
          }

          if (document.lastIndexOf(RECORD_END) + RECORD_END.length()
                  &lt; document.length()) {
              newDoc = document.substring(0,
                      document.lastIndexOf(RECORD_END) + RECORD_END.length());
              newPartialEvent = document.substring(
                      document.lastIndexOf(RECORD_END) + RECORD_END.length());
          } else {
              newDoc = document;
          }
          if (partialEvent != null) {
              newDoc = partialEvent + newDoc;
          }
          partialEvent = newPartialEvent;

          Document doc = parse(newDoc);
          if (doc == null) {
              return null;
          }
          return decodeEvents(doc);
      }
      return null;
  }

    /**
      * Converts the string data into an XML Document, and then soaks out the
      * relevant bits to form a new LoggingEvent instance which can be used
      * by any Log4j element locally.
      * @param data XML fragment
      * @return a single LoggingEvent or null
      */
  public LoggingEvent decode(final String data) {
    Document document = parse(data);

    if (document == null) {
      return null;
    }

    Vector events = decodeEvents(document);

    if (events.size() &gt; 0) {
      return (LoggingEvent) events.firstElement();
    }

    return null;
  }

  /**
   * Given a Document, converts the XML into a Vector of LoggingEvents.
   * @param document XML document
   * @return Vector of LoggingEvents
   */
  private Vector decodeEvents(final Document document) {
    Vector events = new Vector();</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/apache/log4j/rule/AndRule.java</td><td>101</td></tr><tr class="a"><td>org/apache/log4j/rule/OrRule.java</td><td>101</td></tr><tr class="b"><td colspan='2'><div><pre>        if (result) {
            for (Iterator iter = tempMatches1.entrySet().iterator();iter.hasNext();) {
                Map.Entry entry = (Map.Entry)iter.next();
                Object key = entry.getKey();
                Set value = (Set)entry.getValue();
                Set mainSet = (Set) matches.get(key);
                if (mainSet == null) {
                    mainSet = new HashSet();
                    matches.put(key, mainSet);
                }
                mainSet.addAll(value);
            }
            for (Iterator iter = tempMatches2.entrySet().iterator();iter.hasNext();) {
                Map.Entry entry = (Map.Entry)iter.next();
                Object key = entry.getKey();
                Set value = (Set)entry.getValue();
                Set mainSet = (Set) matches.get(key);
                if (mainSet == null) {
                    mainSet = new HashSet();
                    matches.put(key, mainSet);
                }
                mainSet.addAll(value);
            }
        }
        return result;
  }
}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/apache/log4j/rule/LevelEqualsRule.java</td><td>61</td></tr><tr class="a"><td>org/apache/log4j/rule/NotLevelEqualsRule.java</td><td>61</td></tr><tr class="b"><td colspan='2'><div><pre>    private LevelEqualsRule(final Level level) {
        super();
        this.level = level;
    }

    /**
     * Populate list of levels.
     */
    private static void populateLevels() {
        levelList = new LinkedList();

        levelList.add(Level.FATAL.toString());
        levelList.add(Level.ERROR.toString());
        levelList.add(Level.WARN.toString());
        levelList.add(Level.INFO.toString());
        levelList.add(Level.DEBUG.toString());
		Level trace = Level.toLevel(5000, null);
		if (trace != null) {
			levelList.add(trace.toString());
	    }
    }

    /**
     * Create new rule.
     * @param value name of level.
     * @return instance of LevelEqualsRule.
     */
    public static Rule getRule(final String value) {
        Level thisLevel;
        if (levelList.contains(value.toUpperCase())) {
            thisLevel = Level.toLevel(value.toUpperCase());
          } else {
            thisLevel = UtilLoggingLevel.toLevel(value.toUpperCase());
        }

        return new LevelEqualsRule(thisLevel);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/apache/log4j/rule/LevelEqualsRule.java</td><td>106</td></tr><tr class="a"><td>org/apache/log4j/rule/NotLevelEqualsRule.java</td><td>106</td></tr><tr class="b"><td colspan='2'><div><pre>        boolean result = (level.toInt() == eventLevel.toInt());
        if (result &amp;&amp; matches != null) {
            Set entries = (Set) matches.get(LoggingEventFieldResolver.LEVEL_FIELD);
            if (entries == null) {
                entries = new HashSet();
                matches.put(LoggingEventFieldResolver.LEVEL_FIELD, entries);
            }
            entries.add(eventLevel);
        }
        return result;
    }

    /**
     * Deserialize the state of the object.
     *
     * @param in object input stream.
     *
     * @throws IOException if error in reading stream for deserialization.
     */
    private void readObject(final java.io.ObjectInputStream in)
            throws IOException {
        populateLevels();
        boolean isUtilLogging = in.readBoolean();
        int levelInt = in.readInt();
        if (isUtilLogging) {
            level = UtilLoggingLevel.toLevel(levelInt);
        } else {
            level = Level.toLevel(levelInt);
        }
    }

    /**
     * Serialize the state of the object.
     *
     * @param out object output stream.
     *
     * @throws IOException if error in writing stream during serialization.
     */
    private void writeObject(final java.io.ObjectOutputStream out)
            throws IOException {
        out.writeBoolean(level instanceof UtilLoggingLevel);
        out.writeInt(level.toInt());
    }
}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/apache/log4j/extras/SoundAppender.java</td><td>47</td></tr><tr class="a"><td>org/apache/log4j/varia/SoundAppender.java</td><td>44</td></tr><tr class="b"><td colspan='2'><div><pre>public final class SoundAppender extends AppenderSkeleton {

	private AudioClip clip;
	private String audioURL;

	public SoundAppender() {
	}

	/**
	 * Attempt to initialize the appender by creating a reference to an AudioClip.
	 * 
	 * Will log a message if format is not supported, file not found, etc.
	 * 
	 */
	public void activateOptions() {
		/*
		 * AudioSystem.getAudioInputStream requires jdk 1.3,
		 * so we use applet.newaudioclip instead
		 *
		 */
		try {
			clip = Applet.newAudioClip(new URL(audioURL));
		} catch (MalformedURLException mue) {
            LogLog.error(&quot;unable to initialize SoundAppender&quot;, mue);}
		if (clip == null) {
		      LogLog.error(&quot;Unable to initialize SoundAppender&quot;);
		}
	}

	/**
	 * Accessor
	 * 
	 * @return audio file
	 */
	public String getAudioURL() {
		return audioURL;
	}

	/**
	 * Mutator - common format for a file-based url:
	 * file:///c:/path/someaudioclip.wav
	 * 
	 * @param audioURL
	 */
	public void setAudioURL(String audioURL) {
		this.audioURL = audioURL;
	}

	/**
	 * Play the sound if an event is being processed
	 */
	protected void append(LoggingEvent event) {
		if (clip != null) {
			clip.play();
		}
	}

	public void close() {
		//nothing to do
	}

    /**
     * Gets whether appender requires a layout.
     * @return false
     */
  public boolean requiresLayout() {
      return false;
  }

}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/apache/log4j/rolling/helper/GZCompressAction.java</td><td>60</td></tr><tr class="a"><td>org/apache/log4j/rolling/helper/ZipCompressAction.java</td><td>61</td></tr><tr class="b"><td colspan='2'><div><pre>  public GZCompressAction(
    final File source, final File destination, final boolean deleteSource) {
    if (source == null) {
      throw new NullPointerException(&quot;source&quot;);
    }

    if (destination == null) {
      throw new NullPointerException(&quot;destination&quot;);
    }

    this.source = source;
    this.destination = destination;
    this.deleteSource = deleteSource;
  }

  /**
   * Compress.
   * @return true if successfully compressed.
   * @throws IOException on IO exception.
   */
  public boolean execute() throws IOException {
    return execute(source, destination, deleteSource);
  }

  /**
   * Compress a file.
   *
   * @param source file to compress, may not be null.
   * @param destination compressed file, may not be null.
   * @param deleteSource if true, attempt to delete file on completion.  Failure to delete
   * does not cause an exception to be thrown or affect return value.
   * @return true if source file compressed.
   * @throws IOException on IO exception.
   */
  public static boolean execute(
    final File source, final File destination, final boolean deleteSource)
          throws IOException {
    if (source.exists()) {
      FileInputStream fis = new FileInputStream(source);
      FileOutputStream fos = new FileOutputStream(destination);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/apache/log4j/receivers/net/MulticastAppender.java</td><td>87</td></tr><tr class="a"><td>org/apache/log4j/receivers/net/UDPAppender.java</td><td>107</td></tr><tr class="b"><td colspan='2'><div><pre>     super(false);
  }

  /**
     Open the multicast sender for the &lt;b&gt;RemoteHost&lt;/b&gt; and &lt;b&gt;Port&lt;/b&gt;.
  */
  public void activateOptions() {
    try {
      hostname = InetAddress.getLocalHost().getHostName();
    } catch (UnknownHostException uhe) {
      try {
        hostname = InetAddress.getLocalHost().getHostAddress();
      } catch (UnknownHostException uhe2) {
        hostname = &quot;unknown&quot;;
      }
    }

    //allow system property of application to be primary
    if (application == null) {
      application = System.getProperty(Constants.APPLICATION_KEY);
    } else {
      if (System.getProperty(Constants.APPLICATION_KEY) != null) {
        application = application + &quot;-&quot; + System.getProperty(Constants.APPLICATION_KEY);
      }
    }

    if(remoteHost != null) {
      address = getAddressByName(remoteHost);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/apache/log4j/receivers/xml/XMLDecoder.java</td><td>356</td></tr><tr class="a"><td>org/apache/log4j/receivers/xml/XMLDecoder.java</td><td>396</td></tr><tr class="b"><td colspan='2'><div><pre>          NodeList propertyList = list.item(y).getChildNodes();
          int propertyLength = propertyList.getLength();

          for (int i = 0; i &lt; propertyLength; i++) {
            String propertyTag = propertyList.item(i).getNodeName();

            if (propertyTag.equalsIgnoreCase(&quot;log4j:data&quot;)) {
              Node property = propertyList.item(i);
              String name =
                property.getAttributes().getNamedItem(&quot;name&quot;).getNodeValue();
              String value =
                property.getAttributes().getNamedItem(&quot;value&quot;).getNodeValue();
              properties.put(name, value);
            }
          }
        }

        if (tagName.equalsIgnoreCase(&quot;log4j:throwable&quot;)) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/apache/log4j/rolling/RollingFileAppender.java</td><td>246</td></tr><tr class="a"><td>org/apache/log4j/rolling/RollingFileAppender.java</td><td>294</td></tr><tr class="b"><td colspan='2'><div><pre>              closeWriter();

              boolean success = true;

              if (rollover.getSynchronous() != null) {
                success = false;

                try {
                  success = rollover.getSynchronous().execute();
                } catch (Exception ex) {
                  exception = ex;
                }
              }

              if (success) {
                if (rollover.getAppend()) {
                  fileLength = new File(rollover.getActiveFileName()).length();
                } else {
                  fileLength = 0;
                }

                if (rollover.getAsynchronous() != null) {
                  lastRolloverAsyncAction = rollover.getAsynchronous();
                  new Thread(lastRolloverAsyncAction).start();
                }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/apache/log4j/receivers/xml/UtilLoggingXMLDecoder.java</td><td>407</td></tr><tr class="a"><td>org/apache/log4j/receivers/xml/XMLDecoder.java</td><td>426</td></tr><tr class="b"><td colspan='2'><div><pre>            }
        }

      LocationInfo info;
      if ((fileName != null)
              || (className != null)
              || (methodName != null)
              || (lineNumber != null)) {
          info = new LocationInfo(fileName, className, methodName, lineNumber);
      } else {
        info = LocationInfo.NA_LOCATION_INFO;
      }

        ThrowableInformation throwableInfo = null;
        if (exception != null) {
            throwableInfo = new ThrowableInformation(exception);
        }

        LoggingEvent loggingEvent = new LoggingEvent(null,
                logger, timeStamp, level, message,
                threadName,
                throwableInfo,
                ndc,
                info,
                properties);

      events.add(loggingEvent);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/apache/log4j/rule/LevelEqualsRule.java</td><td>64</td></tr><tr class="a"><td>org/apache/log4j/rule/LevelInequalityRule.java</td><td>57</td></tr><tr class="b"><td>org/apache/log4j/rule/NotLevelEqualsRule.java</td><td>64</td></tr><tr class="a"><td colspan='2'><div><pre>    }

    /**
     * Populate list of levels.
     */
    private static void populateLevels() {
        levelList = new LinkedList();

        levelList.add(Level.FATAL.toString());
        levelList.add(Level.ERROR.toString());
        levelList.add(Level.WARN.toString());
        levelList.add(Level.INFO.toString());
        levelList.add(Level.DEBUG.toString());
		Level trace = Level.toLevel(5000, null);
		if (trace != null) {
			levelList.add(trace.toString());
	    }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/apache/log4j/receivers/xml/UtilLoggingXMLDecoder.java</td><td>435</td></tr><tr class="b"><td>org/apache/log4j/receivers/xml/XMLDecoder.java</td><td>462</td></tr><tr class="a"><td colspan='2'><div><pre>    }
    return events;
  }

    /**
     * Get contents of CDATASection.
     * @param n CDATASection
     * @return text content of all text or CDATA children of node.
     */
  private String getCData(final Node n) {
    StringBuffer buf = new StringBuffer();
    NodeList nl = n.getChildNodes();

    for (int x = 0; x &lt; nl.getLength(); x++) {
      Node innerNode = nl.item(x);

      if (
        (innerNode.getNodeType() == Node.TEXT_NODE)
          || (innerNode.getNodeType() == Node.CDATA_SECTION_NODE)) {
        buf.append(innerNode.getNodeValue());
      }
    }

    return buf.toString();
  }
}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/apache/log4j/receivers/net/SocketNode13.java</td><td>201</td></tr><tr class="b"><td>org/apache/log4j/receivers/net/XMLSocketNode.java</td><td>175</td></tr><tr class="a"><td colspan='2'><div><pre>          }
        }
      } catch (java.io.EOFException e) {
        getLogger().info(&quot;Caught java.io.EOFException closing connection.&quot;);
        listenerException = e;
      } catch (java.net.SocketException e) {
        getLogger().info(&quot;Caught java.net.SocketException closing connection.&quot;);
        listenerException = e;
      } catch (IOException e) {
        getLogger().info(&quot;Caught java.io.IOException: &quot; + e);
        getLogger().info(&quot;Closing connection.&quot;);
        listenerException = e;
      } catch (Exception e) {
        getLogger().error(&quot;Unexpected exception. Closing connection.&quot;, e);
        listenerException = e;
      }
    }

    // close the socket
    try {
      if (ois != null) {</pre></div></td></tr></table></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xleft">Copyright &#169;                    2013
                        <a href="http://www.apache.org/">The Apache Software Foundation</a>.
                  
        
       Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache Software License, Version 2.0</a>.</div>
      <div class="xleft">Apache Extras for Apache log4j, Apache log4j, Apache, the Apache feather logo,
   the Apache Logging Services project logo, the log4j logo, and the Built by Maven logo are trademarks of The Apache Software Foundation.</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
